//https://arduino-projects-free.blogspot.com/2019/04/64x32-rgb-led-matrix-clock-with-esp8266.html
// This is how many color levels the display shows - the more the slower the update
//#define PxMATRIX_COLOR_DEPTH 4

// Defines the speed of the SPI bus (reducing this may help if you experience noisy images)
//#define PxMATRIX_SPI_FREQUENCY 20000000

// Creates a second buffer for backround drawing (doubles the required RAM)
//#define PxMATRIX_double_buffer true

#include <PxMatrix.h>
#include <Fonts/TomThumb.h>
#include <Fonts/Org_01.h>

#include <Fonts/FreeSansBoldOblique9pt7b.h>
#include <Fonts/FreeSansBoldOblique12pt7b.h>

#define btnRIGHT 0
#define btnUP 1
#define btnDOWN 2
#define btnLEFT 3
#define btnSELECT 4
#define btnNONE 5

//убрать в Meter!!!
unsigned long nrt = 0;
boolean lastCicleWasNoRunning = false;


int pin = 13;
int val = 1; // включение/выключение хранения значения
volatile int state = LOW;
int adc_key_in = 0;
  
// Pins for LED MATRIX
#ifdef ESP32

#define P_LAT 22
#define P_A 19
#define P_B 23
#define P_C 18
#define P_D 5
#define P_E 15
#define P_OE 16
hw_timer_t * timer = NULL;
portMUX_TYPE timerMux = portMUX_INITIALIZER_UNLOCKED;

#endif

int analogPin = A0; // for ESP8266 microcontroller
int digitalPin = D3; // for ESP8266 microcontroller
#define DHTPIN 0

#ifdef ESP8266

#include <Ticker.h>
Ticker display_ticker;
#define P_LAT 16
#define P_A 5
#define P_B 4
#define P_C 15
#define P_D 12
#define P_E 0
#define P_OE 2

#endif

#define matrix_width 32
#define matrix_height 16

// This defines the 'on' time of the display is us. The larger this number,
// the brighter the display. If too large the ESP will crash
uint8_t display_draw_time=10; //30-70 is usually fine

//PxMATRIX display(32,16,P_LAT, P_OE,P_A,P_B,P_C);
PxMATRIX display(64,32,P_LAT, P_OE,P_A,P_B,P_C,P_D);
//PxMATRIX display(64,64,P_LAT, P_OE,P_A,P_B,P_C,P_D,P_E);

// Some standard colors
uint16_t myRED = display.color565(255, 0, 0);
uint16_t myGREEN = display.color565(0, 255, 0);
uint16_t myBLUE = display.color565(0, 0, 255);
uint16_t myWHITE = display.color565(255, 255, 255);
uint16_t myYELLOW = display.color565(255, 255, 0);
uint16_t myCYAN = display.color565(0, 255, 255);
uint16_t myMAGENTA = display.color565(255, 0, 255);
uint16_t myBLACK = display.color565(0, 0, 0);

uint16_t myCOLORS[8]={myRED,myGREEN,myBLUE,myWHITE,myYELLOW,myCYAN,myMAGENTA,myBLACK};

uint8_t static weather_icons[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0xff,0xe0,0x00,0x00,0x00,0x00,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00
  ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xdf,0x07,0xdf,0x07,0xdf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x20,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xdf,0x00,0x00,0x00,0x00,0x07,0xff,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x00
  ,0x00,0x00,0x00,0x00,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0xff,0xe0,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xdf,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00
  ,0x00,0x20,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0xff,0xe0,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xdf,0x07,0xff,0x07,0xdf,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xdf,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xdf,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x07,0xdf,0x07,0xdf,0x07,0xff,0xff,0xe0,0xff,0xe0,0x00,0x00
  ,0x00,0x00,0xff,0xe0,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xdf,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0xff,0xe0,0x00,0x20,0x00,0x00,0x07,0xdf,0x07,0xdf,0x07,0xdf,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xdf,0x07,0xdf,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0xff,0xff,0x07,0xff,0x07,0xff,0x07,0xdf,0x07,0xff,0x00,0x00,0x07,0xff,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xdf,0x00,0x00,0x00,0x00,0x07,0xff,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00
  ,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xdf,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x07,0xff,0x00,0x20,0xff,0xff,0x00,0x00,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x00,0x00,0xff,0xff,0x00,0x00,0xff,0xff,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xdf,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xdf,0x00,0x00,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xdf,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0xff,0xe0,0xff,0xe0,0x07,0xdf,0x07,0xdf,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00
  ,0x00,0x00,0x00,0x00,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0xff,0xe0,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x00,0x00,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0xff,0xe0,0xff,0xe0,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00
  ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xdf,0x07,0xdf,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x00,0x00,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x00,0x00,0xff,0xff,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xdf,0x07,0xff,0x00,0x00,0x00,0x00,0x07,0xff,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00
  ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xdf,0x07,0xdf,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x00,0x00,0xff,0xff,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xdf,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0x07,0xdf,0x07,0xff,0x07,0xff,0x00,0x00,0x00,0x00,0x00,0x00
  ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

#ifdef ESP8266
// ISR for display refresh
void display_updater()
{
  display.display(display_draw_time);
}
#endif

#ifdef ESP32
void IRAM_ATTR display_updater(){
  // Increment the counter and set the time of ISR
  portENTER_CRITICAL_ISR(&timerMux);
  display.display(display_draw_time);
  portEXIT_CRITICAL_ISR(&timerMux);
}
#endif


void display_update_enable(bool is_enable)
{

#ifdef ESP8266
  if (is_enable)
    display_ticker.attach(0.004, display_updater);
  else
    display_ticker.detach();
#endif

#ifdef ESP32
  if (is_enable)
  {
    timer = timerBegin(0, 80, true);
    timerAttachInterrupt(timer, &display_updater, true);
    timerAlarmWrite(timer, 4000, true);
    timerAlarmEnable(timer);
  }
  else
  {
    timerDetachInterrupt(timer);
    timerAlarmDisable(timer);
  }
#endif
}



void setup() {

 Serial.begin(9600);

  /*
  pinMode(pin, OUTPUT);
  attachInterrupt(1, blink, CHANGE);
  */
  //attachInterrupt(DHTPIN, blink, CHANGE);
 
  // Define your display layout here, e.g. 1/8 step, and optional SPI pins begin(row_pattern, CLK, MOSI, MISO, SS)
  display.begin(16);
  pinMode(DHTPIN, INPUT);
  
 display_update_enable(true);

}

unsigned long last_draw=0;

uint8_t icon_index=0;


volatile byte rh;

unsigned long timeEmul = 0;
byte emulCnt;

////hall
const int ledPin = 13;//the led attach to pin13
int sensorPin = 5; // select the input pin for the potentiometer
int sensorValue = 0;// variable to store the value coming from A0
boolean digitalValue=0;// variable to store the value coming from pin2

////hall

float spinDistance = 0.6;

enum LCD_SHOW_MODE {

  m_WAIT

};

enum TM_STATE {

  s_WAIT,
  s_STARTING, //переходит после нажатия кнопки старт
  s_STARTED,  //Наступает после первого оборота
  s_PAUSED

};

// read the buttons 
int read_LCD_buttons() {
  //return btnNONE;
  adc_key_in = analogRead(0); // read the value from the sensor  
  // my buttons when read are centered at these valies: 0, 144, 329, 504, 741 
  // we add approx 50 to those values and check to see if we are close 
  if (adc_key_in > 1000) return btnNONE; // We make this the 1st option for speed reasons since it will be the most likely result 
  if (adc_key_in < 50) return btnRIGHT;
  if (adc_key_in < 195) return btnUP;
  if (adc_key_in < 380) return btnDOWN;
  if (adc_key_in < 555) return btnLEFT;
  if (adc_key_in < 790) return btnSELECT;
  return btnNONE; // when all others fail, return this... 
}
class LCD {
  LCD_SHOW_MODE showMode = m_WAIT;
  String printData[2] = {
    String(""),
    String("")
  };
  public:
    LCD() {

    }
    
  

  void repaint(String line1, String line2) {
    /*
    lcd.clear();
    lcd.setCursor(0,0);            // move cursor to second line "1" and 9 spaces over
    lcd.print(line1);
    lcd.setCursor(0,1); 
    lcd.print(line2);
    */
  }
};

class Stack{
  int items[3] = {0, 0, 0};

  public:
    Stack() {

    }

    void push(int val){
      items[0] = items[1];
      items[1] = items[2];
      items[2] = val;
    }

    void clear(){
      items[0] = 0;
      items[1] = 0;
      items[2] = 0;
    }

    
/*
 * 340 690  352
 */

    boolean isMissSpin(){
      if ((items[0]>0) &&  (items[1]>items[0] || items[1]>items[2])){
        float extremeAvgSum = ((float)items[0]+items[2])/2;
        //процент на сколько второе вращение меодленнее первого и третьего
        float prc = items[1]/extremeAvgSum;
        /*
        //если медленее чем на 70, то считаем, что пропустили один оборот
        Serial.print(items[0]);
        Serial.print("  ");
        Serial.print(items[1]);
        Serial.print("  ");
        Serial.print(items[2]);
        Serial.print(" ");
        Serial.print(items[1]);
        Serial.print("/");
        Serial.print(extremeAvgSum);
        Serial.print("=");
        
        Serial.print(prc);
        Serial.println(" ");
        */
        return prc>1.6 && prc<3;
      }

      return false;
    }
    
};

class Meter {
  TM_STATE state = s_WAIT;
  unsigned long startTime=0;
  //время в течении которого таймер НЕ был на паузе, но при этом колесо не вращалось
  unsigned long noRunningTimeTime=0;
  //время в течении которого таймер был на паузе. это значение будет вычититься из общего времени
  unsigned long totalPauseTime=0;
  unsigned long lastSpinTime = 0;
  unsigned long lastRepaint = 0;
  byte lastHallVal;
  int prevBtn = btnNONE;
  unsigned long prevBtnTime = 0;
  unsigned long spinCnt = 0;
  //необходимое количество боротов для измерения средней скорости
  byte spinCountForAWGCalc = 3;
  byte awgSpinCounter;
  float avgSpeed = 0;
  float avgTempo = 0;
  float curSpeed = 0;
  float curTempo = 0;
  boolean halfSpin = false;
  
  
  //время последнего измерения средней скорости
  long lastMeasTime;
  LCD *lcdOb;
  Stack *stack = new Stack();
  public :
  Meter(LCD *val){
    lcdOb = val;
  }

  void start(){
    state = s_STARTING;
    startTime = getTime();
    lastMeasTime = startTime;
    awgSpinCounter = spinCountForAWGCalc;
    spinCnt = 0;
    curSpeed = 0;
    curTempo = 0;
    avgSpeed = 0;
    avgTempo = 0;
    totalPauseTime=0;
    noRunningTimeTime = 0;
    lastSpinTime = 0;
    stack->clear();
    //Serial.println("start");
  }

  void addPauseTime(int t){
    totalPauseTime += t;
  }

  void addNoRunningTimeTime(int t){
    noRunningTimeTime += t;
  }

  boolean isPaused(){
    return state == s_PAUSED;
  }

  boolean isStarted(){
    return state == s_STARTED;
  }
  
  void readHallValue(){
    if (isPaused()){
        return;
    }
    byte rh = readHall();
    //lastHallVal++;
    if (rh != lastHallVal){
      lastHallVal = rh;
      halfSpin = !halfSpin;
      if (halfSpin){
        spin();
      }
    }else if (getTime()-lastSpinTime>3000){
      //calcSpeed();
      curSpeed = 0;
    }
    
  }
  void spin(){

    if (isStarted() && lastCicleWasNoRunning){
      //перенести в spin
      Serial.println("goes out from no running");
      //meter->addNoRunningTimeTime(getTime()-nrt);
      Serial.print("add no running time");
      Serial.println(getTime()-nrt);
      nrt = 0;
      lastCicleWasNoRunning = false;
    }
    unsigned long milsec = getTime();
    long st = milsec-lastSpinTime;
    Serial.print("  S P I N   ");
    Serial.print(spinCnt);
    Serial.print("   ");
    Serial.print( milisToTimeString(milsec));
    Serial.print("   ");
    Serial.println( st);
    stack->push(st);
    lastSpinTime = milsec;
    switch(state){
      case s_STARTING:
        start();
        state = s_STARTED;
        
        break;
      case s_PAUSED:
        return;
      case s_WAIT:
      //если в режиме ожидания начали бежать, то автоматически стартуем
        if (spinCnt>2){
          //state = s_STARTING
          start();
        }
        break;
    }

    spinCnt++;
    
    if (stack->isMissSpin()){
      stack->clear();
      spinCnt++;
      //awgSpinCounter--;
      Serial.println(" ADD missed spin  ");
    }
    

    if (state!=s_STARTED){
      return;
    }
    //Serial.print("spin: ");
    awgSpinCounter--;
    if (awgSpinCounter <=0){
      calcSpeed();
    }

  }

String milisToTimeString(unsigned long ms) {
  unsigned long totalseconds = ms / 1000;
  int hours = totalseconds / 3600;
  int minutes = (totalseconds / 60)%60;
  int seconds = totalseconds % 60;
  String s = ((hours < 10) ? "0" : "") + String(hours) + ":"+ ((minutes < 10) ? "0" : "") + String(minutes) + ":" + ((seconds < 10) ? "0" : "") + String(seconds);
  return s;
}

  

  void calcSpeed(){
    unsigned long currTime = getTime();
    long timeBetwSpins = currTime-lastMeasTime;
    int addSpin =0;//добавим число спинов, если был пропущенный спин, мы его вычли и получили отрицательное число/ этот спин надо учесть при рассчете текущей скорости;
    /*
     * addSpin = awgSpinCounter<0?abs(awgSpinCounter):0;
    Serial.print("timeBetwSpins: ");
    Serial.println(timeBetwSpins);
    
    Serial.print("awgSpinCounter: ");
    Serial.print(awgSpinCounter);
    Serial.print(" awgadd: ");
    Serial.println(addSpin);
    */
    
    float dist = spinDistance*(spinCountForAWGCalc +addSpin);//
    curSpeed = dist/(timeBetwSpins/1000.0);
    float d = getDistance();
    avgSpeed = d/((currTime - startTime - totalPauseTime-noRunningTimeTime)/1000.0);
    avgSpeed = (avgSpeed/1000.0)*3600.0;
    avgTempo = 60/avgSpeed;
    lastMeasTime=currTime;
    
    awgSpinCounter = spinCountForAWGCalc;
    //Serial.print("set new awgSpinCounter: "); Serial.println(awgSpinCounter);
    String totalTime = "";
    /*
    Serial.print("spinCnt: ");
    Serial.println(spinCnt);
    Serial.print("distance: ");
    Serial.println(d);
    */
/*
    Serial.print("curSpeed: ");
    Serial.print(curSpeed);
*/
    curSpeed = (curSpeed/1000.0)*3600.0;
    curTempo = 60/curSpeed;
    /*
    Serial.print(" km/h: ");
    Serial.println(curSpeed);
    
    Serial.print("avgSpeed: ");
    Serial.print(avgSpeed);
    /*
    avgSpeed = (avgSpeed/1000.0)*3600.0;
    /*
    Serial.print(" km/h: ");
    Serial.println(avgSpeed);
    Serial.print(" total time: ");
   */
    //Serial.println( milisToTimeString(currTime - startTime));

  }

unsigned long lastShow = 0;
  void show(){
    if ((getTime()-lastShow)<500){
      return;
    }
    lastShow = getTime();
    display.clearDisplay();
    String line1 = "";
    String line2 = "";
    switch(state){
      case s_WAIT:
          line1 = "      WAIT";
          display.setCursor(20,10);
          display.print("WAIT");    
          
        break;
        case s_STARTING:
          line1 = "   STARTING...";
          display.setCursor(8,10);
  display.print("STARTING");
        break;
        case s_STARTED:
        case s_PAUSED:
             unsigned long currTime = getTime();
              if ((currTime-lastRepaint)<500 ){
                return;
              }
              lastRepaint = currTime;
              unsigned long allTime = currTime - startTime-totalPauseTime;
              String t = milisToTimeString(allTime);
              if (isPaused()){
                if ((currTime % 60)%2 ==0){
                  t = "PAUSED  ";
                }
              }
           String dc = String(getDistance(),0);
           ///*
           if (getDistance()>1000){
            dc = String(getDistance()/1000,2);
           }
           String avgTempoStr = String(avgTempo,1);
           if (avgTempo>99){
            avgTempoStr="----";
           }
           String curTempoStr = String(curTempo,2);
           if (isWaitInStartedMode()){
            curTempoStr="----";
            stack->clear();
           }
           line1=format(format(avgTempoStr, String(avgSpeed,1), 9), dc, 16);
           line2=format(curTempoStr, t, 16);


           
  //display.setFont(&TomThumb);
  //display.setFont(&Org_01);
          display.setTextColor(myCYAN);
          display.setCursor(2,0);
          display.print(format("", dc, 9));
          display.setTextColor(display.color565(255,255,255));
           display.print("m");
          //display.println(dc);
          display.setTextColor(display.color565(255,255,0));
          display.setCursor(2,8);
          display.println(format("", t, 10));
          display.setTextColor(myCYAN);
          display.setCursor(2,16);
          display.print( "Pace");
          display.setTextColor(getColorForPace(curTempo));
          display.print( format("", curTempoStr, 6));
          display.setTextColor(myCYAN);
          display.setTextColor(getColorForPace(avgTempo));
          display.setCursor(2,24);
          display.print(avgTempoStr);
          display.setCursor(30,24);
          display.setTextColor(myCYAN);
          display.print( format("", String(avgSpeed,1), 5) );


           //*/
           //line1 = dc;
        break;
    }
    //char TextBuffer[16];
    //snprintf  (TextBuffer,  sizeof(buff), "%f", avgSpeed);

    lcdOb->repaint (
      line1,line2);
  }

  uint16_t getColorForPace(float pace){
    if (pace<=5){
      return  display.color565(0, 255, 0);
    }else if (pace<=5.5){
      return  display.color565(100, 255, 0);
    }else if (pace<=6){
      return  display.color565(200, 255, 0);
    }else if (pace<=7){
      return  display.color565(255, 119, 0);
    }else if (pace<=7.5){
      return  display.color565(255, 68, 0);
    }
    return  display.color565(255, 0, 0);
  }

  boolean isWaitInStartedMode(){
    return (curTempo>99) || (curSpeed == 0);
  }

  String format(String s1, String s2, int resLen){
    byte l1 = s1.length();
    byte l2 = s2.length();
    if (l1+l2<resLen){
      for (byte i=0; i<resLen-l1-l2; i++){
        s1+=" ";
      }
      s1 += s2;
    }else{
      s1+=' '+s2;
    }
    return s1;
  }
  

  float getDistance(){
    float d = spinDistance*spinCnt; return d;
    //return spinDistance*spinCnt;
  }

  void onButtonClick() {
  unsigned long milsec = getTime();
    int btn = read_LCD_buttons();
    if (btn!=btnNONE){
      if (prevBtn == btn && (milsec-prevBtnTime)<500){

        return;  
      }
      prevBtn = btn;
      prevBtnTime = milsec;
      Serial.print("button:");
      Serial.println(btn);
    }

    switch (btn) {
      case btnSELECT:
      if (state == s_PAUSED){
          state = s_STARTED; 
      }else{
        start();
      }
      break;
      case btnLEFT:
        state = s_PAUSED;
      break;
    }
    
  }
};


LCD *lcdObject = new LCD();
Meter *meter = new Meter(lcdObject);

byte readHall(){
  //https://osoyoo.com/2017/07/28/arduino-lesson-hall-effect-sensor-module/
  //sensorValue = analogRead(sensorPin); //read the value of A0
  digitalValue=digitalRead(DHTPIN);
  /*
  Serial.print("Sensor Value "); // print label to serial monitor 
  Serial.println(sensorValue); //print the value of A0
  */
  //Serial.print("Digital Value "); // print label to serial monitor 
  //Serial.println(digitalValue); //print the value of D0 in the serial
/*
  if( digitalValue==HIGH )//if the value of D0 is HIGH
  {
    digitalWrite(ledPin,LOW);//turn off the led
  }
  if( digitalValue==LOW)//else
  {
    digitalWrite(ledPin,HIGH);//turn on the led
  }
  */
  return digitalValue;
}

unsigned long getTime(){
  return millis();
  //return timeEmul;
}



void blink()
{
  state = !state;
  Serial.print("BLONK!!!");
  Serial.println(state);
}

void loop() {
  
  unsigned long t = getTime();
  
  meter->readHallValue(); // c ним не падало
  
  meter->show();
//  meter -> onButtonClick();
  delay(0);
  if (meter->isPaused()){
    meter->addPauseTime(getTime()-t);  
  }else if (meter->isWaitInStartedMode()){
    if (!lastCicleWasNoRunning){
      Serial.println("goes to no running");
      nrt = getTime();
    }
    lastCicleWasNoRunning = true;
  }else{
    /*
    if ( meter->isStarted() && lastCicleWasNoRunning){
      //перенести в spin
      Serial.println("goes out from no running");
      //meter->addNoRunningTimeTime(getTime()-nrt);
      Serial.print("add no running time");
      Serial.println(getTime()-nrt);
      nrt = 0;
      
    }
    */
  }




  
int analogVal = analogRead(analogPin);
  int digitalVal = digitalRead(DHTPIN);
  //Serial.print(analogVal);
  //Serial.print("\t");
  //Serial.println(digitalVal);
  //delay(100);
}


